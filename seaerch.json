[{"title":"977_有序数组的平方","path":"/2025/06/25/977-有序数组的平方/","content":"977. 有序数组的平方977. 有序数组的平方 该题的暴力解法就是：先排序，再平方；或者先平方，再排序 该题也可以使用双指针法，因为当前的数组其实是有序的，只不过可能绝对值的大小不一致 但是可以通过观察得出，平方后最大的值都会在两侧，所以就可以用两个指针分别指向数组的两侧，然后比较两侧的数值的平方的大小 定义一个新的数组，将上面比较得出的较大的值按照从右到左的方式进行赋值，这样就可以减少排序所带来的时间消耗 class Solution public: vectorint sortedSquares(vectorint A) int k = A.size() - 1; vectorint result(A.size(), 0); // for循环中的判断条件为 i = j // 因为要处理最后剩下的两个元素，如果没有等号的话，就会遗漏掉部分数据 for (int i = 0, j = A.size() - 1; i = j) if (A[i] * A[i] A[j] * A[j]) result[k--] = A[j] * A[j]; j--; else result[k--] = A[i] * A[i]; i++; return result;","categories":["LeetCode/数组"]},{"title":"27_移除元素","path":"/2025/06/25/27-移除元素/","content":"27. 移除元素27. 移除元素 该题最朴素的方法就是直接两层for循环，每次删除一个元素，然后将后续的元素往前移一位，这样的时间复杂度就是 O(n^2) 而本题中更优的方法是使用双指针法（快慢指针法），时间复杂度是 O(n) 快指针：寻找新数组的元素，新数组就是不含有目标元素的数组（换句话说，如果碰到要删除的值，快指针直接跳过） 慢指针：指向更新 新数组下标的位置（当慢指针碰到要删除的值，用快指针所指的值进行覆盖） class Solution public: int removeElement(vectorint nums, int val) int slowIndex = 0; for (int fastIndex = 0; fastIndex nums.size(); fastIndex++) if (val != nums[fastIndex]) // 如果遇到val==nums[fastIndex]，fastIndex直接往后一位 nums[slowIndex++] = nums[fastIndex]; return slowIndex;","categories":["LeetCode/数组"]},{"title":"704_二分查找","path":"/2025/06/25/704-二分查找/","content":"704. 二分查找704. 二分查找 经典老题二分查找，思路简单，但是不一定能一遍过 重点在于边界条件，是使用 left right 还是 left right，要取决于解题的思路 如果使用 左闭右开 的思路，那就使用 left right，要注意边界的判断条件，每次判断后 mid 的变化也不同 如果使用 左闭右闭 的思路，那就使用 left right 左闭右闭 (left right): class Solution public: int search(vectorint nums, int target) int left = 0; int right = nums.size() - 1; // 定义target, [left, right] while (left = right) // 当 left==right, 区间[left,right]仍然有效，依旧需要进入循环判断 int middle = left + ((right - left) / 2); // 防止溢出，等同于(left + right) / 2 if (nums[middle] target) right = middle - 1; // target 在左区间，所以[left, middle - 1] else if (nums[middle] target) left = middle + 1; // target 在右区间，所以[middle + 1, right] else return middle; return -1; 左闭右开 (left right): class Solution public: int search(vectorint nums, int target) int left = 0; int right = nums.size(); // 定义target在左闭右开的区间里，即 [left, right) while (left right) // 因为left == right的时候，在[left, right)是无效的空间 int middle = left + ((right - left) / 2); if (nums[middle] target) right = middle; else if (nums[middle] target) left = middle; else return middle; return -1;","categories":["LeetCode/数组"]},{"title":"209_长度最小的子数组","path":"/2025/06/23/209-长度最小的子数组/","content":"209. 长度最小的子数组209. 长度最小的子数组 该题最朴素的思路就是两层for循环，但是当然我们希望用更优的方法去解决，所以通过该题需要了解的是 滑动窗口法（或者称为 双指针法），就是通过一个可变动大小的窗口（分别由快慢指针去控制窗口大小）来控制子数组的长度，然后记录最小的子数组长度 其中快指针是用于遍历整个数组的，是不断往后遍历的；慢指针是用于控制窗口大小，以保证窗口内元素之和大于target，当窗口内元素之和大于target时，可以尽可能地使慢指针往后移动，使窗口尽可能小 可以看到下方的解题代码是使用 j 作为快指针，不断地往后去遍历整个数组，而 i 是用于调节窗口大小的 当 j 往后遍历时，就去判断当前窗口内元素之和是否大于target，若符合条件，则将 i 往后调整，使得在满足窗口内元素之和大于target的条件下，窗口尽可能小（也就是子数组长度尽可能小） C++代码如下： class Solution public: int minSubArrayLen(int s, vectorint nums) int result = INT32_MAX; int sum = 0; // 滑动窗口数值之和 int i = 0; // 滑动窗口起始位置 int subLength = 0; // 滑动窗口的长度 for (int j = 0; j nums.size(); j++) sum += nums[j]; // 此处使用while，每次更新i(起始位置)，并不断比较子序列是否符合条件，核心代码 while (sum = s) subLength = (j - i + 1); // 子数组的长度 result = result subLength ? result : subLength; sum -= nums[i++]; // 不断变更i（子序列的起始位置） return result == INT32_MAX ? 0 : result;","categories":["LeetCode/数组"]},{"title":"59_螺旋矩阵","path":"/2025/06/23/59-螺旋矩阵/","content":"59. 螺旋矩阵59. 螺旋矩阵 该题的重点在于模拟过程，并没有过多的算法思想，但是所需要的条件较多 要画出螺旋形的正方形，最好的方式就是循环地画四条边，如果有多个圈，那就进行多次循环，此时重点就是确定几个关键的要素： 循环的次数 起始位置，结束位置（两者结合起来就是边的长度） 矩阵中间是否需要单独复制元素 可以手动画一个n3和n4的螺旋矩阵，可以发现起始的位置随着循环次数的增加而+1，边的长度相应地-2，但因为我们将起始位置+1了，所以可以使用offset来直接调节边的长度 这里的代码循环的时候遵循的是左闭右开的原则 C++代码如下： class Solution public: vectorvectorint generateMatrix(int n) vectorvectorint res(n, vectorint(n, 0)); int startx = 0, starty = 0; // 定义每次循环一个圈的起始位置 int loop = n / 2; // 每个圈循环几次 int mid = n / 2; // 矩阵中间的位置 int count = 1; // 用来给矩阵中的每个元素赋值 int offset = 1; // 用来控制每一条边的长度，每次循环遍历后长度减1 int i, j; while (loop--) i = startx; j = starty; // 上侧从左到右 for (j; j n - offset; j++) res[i][j] = count++; // 右侧从上到下 for (i; i n - offset; i++) res[i][j] = count++; // 下侧从右到左 for (j; j startx; j--) res[i][j] = count++; // 左侧从下到上 for (i; i starty; i--) res[i][j] = count++; // 第二圈开始，起始位置要各自加1 startx++; starty++; offset++; if (n % 2 != 0) res[mid][mid] = count; return res;","categories":["LeetCode/数组"]},{"title":"资源导航","path":"/2025/05/21/资源导航/","content":"人工智能 李沐老师的深度学习课程 吴恩达机器学习 基础工具使用技能这部分的网站会教授一些学校内可能不会专门开设课程的技能，但是在计算机领域研究过程中可能会用到的一些必要的内容；还有一些可能会用到的工具 missing-semester 实用技能拾遗 Jetbrains Gateway 用简易的方式连接远程服务器，申请education后即可免费使用 XShell Xftp 常用的远程连接工具，也可通过申请education免费使用 NNS（最近邻搜索）基础内容 向量检索经典算法 方便初学者进行了解的中文回答，通俗易懂 NNS算法教程 介绍了最近邻搜索中的一些基础概念（但是当前已经没有进行更新了） NNS算法比较 这个网站中介绍的主要是基于分区的NNS方法 Victor Lavrenko StatQuest with Josh Starmer 论文相关 Papers With Code Connected Papers dblp Trending Papers 数学相关 mml-book 线性代数 Others 莫烦Python 里面包含 机器学习、数据处理、Python教学 及 Git、Linux 等的基础教学 OI-Wiki 一个信息奥赛的Wiki网站，里面包含许多算法方面的内容 graduate_handbook For MS Survival Hexo 简易的博客框架","categories":["科研"]},{"title":"复现实验问题复盘","path":"/2025/05/06/复现实验问题复盘/","content":"复现与实验过程中遇到的问题 前置工作不完善，论文中的算法、数据结构及参数没有提前记录好，需要反复多次（进行不必要的）阅读论文 实验记录不完善，不清晰，没有大致的排期，会导致实验或复现时间过长 项目结构不清晰，参数管理混乱，未使用脚本形式进行参数测试，日志与输出不完善，导致难以排查问题 版本管理混乱 代码能力较差，且在使用AI进行辅助时没有总结规律，prompt质量不高 解决措施（经验教训）实验前置工作 在精读论文，了解文章的核心思路后，开始实验前，需要着重查看 算法部分 和 实验部分，以及其他可能得细节 文章中不熟悉的概念需要理清再进行实验，比如不同的度量（metrics）（比如什么是汉明距离，什么是余弦相似度等），不同的计算公式（求矩阵的特征值、特征向量等），都需要了解清晰再进行实验，否则在实验过程中出现了错误可能自己也不清楚 算法和数据结构 最好能（以伪代码的方式）提前确定好 算法：比如 终止条件是什么，如何剪枝，迭代更新还是可微分 等等 数据结构：比如 某个结构体里面包含哪些内容；某个数据集中需要使用几维矩阵，每一维分别代表什么；某一棵树中的非叶子节点代表什么，叶子节点包含什么 等等 实验的主要内容一般分布在 方法介绍 和 实验 部分，但是有的文章中实验的细节可能会分布在不同的章节中，这就需要去highlight一下 算法和重要的细节（如数据结构、超参数等）最好提前使用笔记本或者电子文档记录好，避免重复翻看论文耗费不必要的时间（如果有细节不清晰的话，当然必须要回看澄清） 对于算法，可以画一个简易的程序流程图整理思路并划分模块，方便后续实现 某些实验细节可能作者没有提及（出于各种原因），所以在阅读论文和实验过程中需要带着批判的态度。如果哪些部分你觉得“这种实现方式可能有问题”，“可能缺少了某些部分”或是“这样实现可能会更好”，那么请记录下来并在后续实现中留意 许多文章中算法的某些模块或是dataset都是现有的SOTA或是已有的Github仓库内容，这种一般正文或是reference中都有提及，但也需要我们去提前了解和熟悉，否则在复现过程中会有一定阻力，并且不同的库的文档都不相同，需要去适应和调整 实验过程中 复现或实验务必做好实验记录（最好开始coding前就开始记录），因为一般实验的战线都不会很短（一两天之类的），时间长会导致人容易遗忘细节，所以需要做好相关记录，并跟踪进度；比如说第几天完成了哪些模块，或是尝试了哪种方法，遇到了哪些bug，避免重复踩进同一个坑 项目结构要清晰（方便调试），最好提前进行模块划分再coding（属于前置工作） 参数最好可以统一管理，并且实验的测试运行应使用脚本的形式，方便自动化调试，尤其对于超参数调优而言 编写过程中，日志与必要的输出不能少，特别在不同的阶段与超参数的记录，这可以有效减少debug的成本；日志最好单独一个目录进行管理，每一次运行单独一个日志文件或是有明确时间戳的单个文件，可以快速定位 coding时要进行版本管理，因为不确定哪一版才是自己真正需要的（Git不太熟悉的话，需要学习与记录） 使用AI辅助coding的话，首先最好进行资料更新，prompt让它了解要实现什么样的效果（我个人会提前把文章给它，让它关注某些我想要实现的部分），然后如果要让其输出具体的代码，需要有较为明确的需求（越具体越好），得到的代码也需要自己审一遍或者跟着敲一遍，因为某些细节的偏差不容易看出来，而这些小问题可能会导致实验结果出现偏差 使用AI进行第三方库代码调用的情况，建议也去自行查看一下第三方库的文档，避免踩坑；我个人之前在调用C++的Eigen库时，查看了官方文档才了解它是以列优先去存储向量的，但我个人的数据是默认以行优先进行向量存储的，而这点AI并没有进行提示，这就很容易出现bug，所以还是得留意一下 可尝试的方法 实验不复杂的情况下，可考虑使用敏捷开发，快速实现demo验证实验流程，一方面增强信息，另一方面确定该思路可行，再进一步完善代码","categories":["科研"]}]